# Використання клієнту Elasticsearch(.js)

# Встановлення ES

Для цього нам спочатку потрібно Java. Розробники рекомендують встановити версії Java новіше, ніж Java 8 update 20 або Java 7 update 55.
Дистрибутив ES доступний на сайті розробника. Після розпакування архіву потрібно запустити bin/elasticsearch.
Після установки і запуску перевіримо працездатність:

http://localhost:9200

Ми отримаємо приблизно таку відповідь:

![image](https://user-images.githubusercontent.com/61386231/111884743-34606b80-89cc-11eb-9e4d-b6693a56c5a7.png)

# Індексація

Додамо пост в ES:

```javascript
// Додамо документ c id 1 типу post в індекс blog.

// Pretty вказує, що висновок повинен бути придатним для читання людиною.


PUT /blog/post/1?pretty
{
  "title": "Доповідь з ІПЗ",
  
  "content": "<p>Історія про довгу підготовку доповіді<p>",
  
  "tags": [
  
    "доповідь",
    
    "ІПЗ"
  ],
  
  "published_at": "2021-03-15T20:44:42+00:00"
  
}
```

Отримаємо таку відповідь серверу:

![image](https://user-images.githubusercontent.com/61386231/112749346-70965c00-8fca-11eb-965b-7e615f4df9c1.png)

ES автоматично створив індекс blog і тип post. Можна провести умовну аналогію: індекс - це база даних, а тип - таблиця в цій БД. Кожен тип має свою схему - mapping, також як і реляційна таблиця. Mapping генерується автоматично при індексації документа:

```javascript
// Отримаємо mapping всіх типів індексу blog

GET /blog/_mapping?pretty
```
відповідь серверу:

![image](https://user-images.githubusercontent.com/61386231/112749395-cbc84e80-8fca-11eb-941c-2aa2d0dea70f.png)

Варто відзначити, що ES не робить різниці між поодиноким значенням і масивом значень. Наприклад, поле title містить просто заголовок, а поле tags - масив рядків, хоча вони представлені в mapping однаково.

# Запити

## Витяг документа по його id:

```javascript
// Винесемо документ з id 1 типу post з індексу blog

GET /blog/post/1?pretty
```

![image](https://user-images.githubusercontent.com/61386231/112760110-8c1b5a00-8ffe-11eb-8756-e4c103657d62.png)

У відповіді з'явилися нові ключі: _version і _source. Взагалі, всі ключі, що починаються з _ відносяться до службових.


Ключ _version показує версію документа. Він потрібен для роботи механізму оптимістичних блокувань. Наприклад, ми хочемо змінити документ, що має версію 1. Ми відправляємо змінений документ і вказуємо, що це правка документа з версією 1. Якщо хтось інший теж редагував документ з версією 1 і відправив зміни раніше нас, то ES не прийме наші зміни, тому він зберігає документ з версією 2.


Ключ _source містить той документ, який ми індексували. ES не використовує це значення для пошукових операцій, тому що для пошуку використовуються індекси. Для економії місця ES зберігає стислий вихідний документ. Якщо нам потрібен тільки id, а не весь вихідний документ, то можна відключити зберігання исходника.


Якщо нам не потрібна додаткова інформація, можна отримати тільки вміст _source:

```javascript
GET /blog/post/1/_source?pretty
```

![image](https://user-images.githubusercontent.com/61386231/112760161-be2cbc00-8ffe-11eb-834a-8f4ecc0eb878.png)

Також можна вибрати тільки певні поля:

```javascript
// Винесемо тільки поле title

GET /blog/post/1?_source=title&pretty
```

![image](https://user-images.githubusercontent.com/61386231/112761471-27fb9480-9004-11eb-8a49-c1cf3803f1d2.png)

Проіндексуємо ще кілька постів і виконаємо більш складні запити.

```javascript
PUT /blog/post/2
{

  "title": "Підготовка прикладів",

  "content": "<p>Пошук найбільш показових та зрозумілих прикладів до доповіді<p>",

  "tags": [

    "приклади",

    "доповідь"

  ],

  "published_at": "2021-02-15T20:44:42+00:00"

}


PUT /blog/post/3
{

  "title": "Як я нарешті знайшов приклади до доповіді",

  "content": "<p>Довга історія з хорошим кінцем<p>",

  "tags": [

    "приклади"

  ],

  "published_at": "2014-07-21T20:44:42+00:00"

}
```

# Сортування

```javascript
// Знайдемо останній пост за датою публікації і винесемо поля title та published_at

GET /blog/post/_search?pretty
{

  "size": 1,

  "_source": ["title", "published_at"],

  "sort": [{"published_at": "desc"}]

}
```

Отримаємо:

![image](https://user-images.githubusercontent.com/61386231/112761849-d5bb7300-9005-11eb-884f-8917e2ae472a.png)

Ми вибрали останній пост. size обмежує кількість документів у видачі. total показує загальне число документів, що підходять під запит. sort у видачі містить масив цілих чисел, за якими проводиться сортування. Тобто дата перетворилася в ціле число.

# Повнотекстовий пошук

Три наших документа містять в полі content наступне:

+ <p>Історія про довгу підготовку доповіді<p>
+ <p>Пошук найбільш показових та зрозумілих прикладів до доповіді<p>
+ <p>Довга історія з хорошим кінцем<p>

Використовуємо match query для пошуку id документів, що містять задане слово:

```javascript
// source: false означає, що не потрібно витягувати _source знайдених документів

GET /blog/post/_search?pretty
{

  "_source": false,

  "query": {

    "match": {

      "content": "історія"

    }

  }

}
```

![image](https://user-images.githubusercontent.com/61386231/112762552-de617880-9008-11eb-9b70-e62063e4a989.png)

Однак, якщо шукати "історії" в поле контент, то ми нічого не знайдемо, тому що в індексі містяться тільки оригінальні слова, а не їх основи. Для того щоб зробити якісний пошук, потрібно налаштувати аналізатор.

Поле _score показує релевантність. Якщо запит виконується в filter context, то значення _score завжди дорівнюватиме 1, що означає повну відповідність фільтру.

# Аналізатори

Аналізатори потрібні, щоб перетворити вихідний текст в набір токенів.
Аналізатори складаються з одного Tokenizer і декількох необов'язкових TokenFilters. Tokenizer може передувати декільком CharFilters. Tokenizer розбивають вихідну рядок на токени, наприклад, по прогалин і символів пунктуації. TokenFilter може змінювати токени, видаляти або додавати нові, наприклад, залишати тільки основу слова, прибирати приводи, додавати синоніми. CharFilter - змінює вихідну рядок цілком, наприклад, вирізає html теги.

У ES є кілька стандартних аналізаторів. Наприклад, аналізатор russian.

Скористаємося api і подивимося, як аналізатори standard і russian перетворять рядок "Веселые истории про котят":
```javascript
# Використовуємо аналізатор standard
# Обов'язково потрібно перекодувати НЕ ASCII символи
curl -XGET "$ ES_URL / _analyze? pretty & analyzer = standard & text =% D0% 92% D0% B5% D1% 81% D0% B5% D0% BB% D1% 8B% D0% B5% 20% D0% B8% D1% 81% D1% 82% D0% BE% D1% 80% D0% B8% D0% B8% 20% D0% BF% D1% 80% D0% BE% 20% D0% BA% D0% BE% D1% 82% D1% 8F% D1% 82 "
```

![image](https://user-images.githubusercontent.com/61386231/116445904-0f7ad600-a85f-11eb-8b2b-c67b1ca6f66b.png)

```javascript
# Використовуємо аналізатор russian
curl -XGET "$ ES_URL / _analyze? pretty & analyzer = russian & text =% D0% 92% D0% B5% D1% 81% D0% B5% D0% BB% D1% 8B% D0% B5% 20% D0% B8% D1% 81% D1% 82% D0% BE% D1% 80% D0% B8% D0% B8% 20% D0% BF% D1% 80% D0% BE% 20% D0% BA% D0% BE% D1% 82% D1% 8F% D1% 82 "
```

![image](https://user-images.githubusercontent.com/61386231/116445990-2a4d4a80-a85f-11eb-80c6-fc6d1923e332.png)

Стандартний аналізатор розбив рядок по прогалин і перевів все в нижній регістр, аналізатор russian - прибрати не значущі слова, перевів в нижній регістр і залишив основу слів.

Подивимося, які Tokenizer, TokenFilters, CharFilters використовує аналізатор russian:

![image](https://user-images.githubusercontent.com/61386231/116446051-40f3a180-a85f-11eb-9209-8ae886ab6763.png)

Опишемо свій аналізатор на основі russian, який буде вирізати html теги. Назвемо його default, тому що аналізатор з таким ім'ям буде використовуватися за замовчуванням.

![image](https://user-images.githubusercontent.com/61386231/116446133-536ddb00-a85f-11eb-92bf-d6e1bf098ae3.png)

Спочатку з початкового рядка втечуть всі html теги, потім її розіб'є на токени tokenizer standard, отримані токени перейдуть в нижній регістр, втечуть незначущі слова і від решти токенов залишиться основа слова.

# Створення індексу

Вище ми описали default аналізатор. Він буде застосовуватися до всіх строкових полях. Наш пост містить масив тегів, відповідно, теги теж будуть оброблені аналізатором. Оскільки ми шукаємо пости по точній відповідності тегу, то необхідно відключити аналіз для поля tags.

Створимо індекс blog2 з аналізатором і маппінгом, в якому відключено аналіз поля tags:

![image](https://user-images.githubusercontent.com/61386231/116446397-9a5bd080-a85f-11eb-92fb-5e56d9e5f74b.png)

Додамо ті ж 3 поста в цей індекс (blog2). Я опущу цей процес, тому що він аналогічний додаванню документів в індекс blog.

# Повнотекстовий пошук з підтримкою виразів

Познайомимося з ще одним типом запитів:

```javascript
# Знайдемо документи, в яких зустрічається слово 'історії'
# Query -> simple_query_string -> query містить пошуковий запит
# Поле title має пріоритет 3
# Поле tags має пріоритет 2
# Поле content має пріоритет 1
# Пріоритет використовується при ранжируванні результатів
curl -XPOST "$ ES_URL / blog2 / post / _search? pretty" -d '
{
   "Query": {
     "Simple_query_string": {
       "Query": "історії",
       "Fields": [
         "Title ^ 3",
         "Tags ^ 2",
         "Content"
       ]
     }
   }
}
```

Оскільки ми використовуємо аналізатор з російським стемінгом, то цей запит поверне всі документи, хоча в них зустрічається тільки слово 'історія'.

Запит може містити спеціальні символи, наприклад:

```javascript
"\"fried eggs\" +(eggplant | potato) -frittata"
```

Синтаксис запиту:

```javascript
+ signifies AND operation
| signifies OR operation
- negates a single token
" wraps a number of tokens to signify a phrase for searching
* at the end of a term signifies a prefix query
( and ) signify precedence
~N after a word signifies edit distance (fuzziness)
~N after a phrase signifies slop amount
```

```javascript
# Знайдемо документи без слова 'цуценята'
curl -XPOST "$ ES_URL / blog2 / post / _search? pretty" -d '
{
   "Query": {
     "Simple_query_string": {
       "Query": "-щенкі",
       "Fields": [
         "Title ^ 3",
         "Tags ^ 2",
         "Content"
       ]
     }
   }
} '

# Отримаємо 2 пости про котиків
```
