# Використання клієнту Elasticsearch(.js)

# Встановлення ES

Для цього нам спочатку потрібно Java. Розробники рекомендують встановити версії Java новіше, ніж Java 8 update 20 або Java 7 update 55.
Дистрибутив ES доступний на сайті розробника. Після розпакування архіву потрібно запустити bin/elasticsearch.
Після установки і запуску перевіримо працездатність:

http://localhost:9200

Ми отримаємо приблизно таку відповідь:

![image](https://user-images.githubusercontent.com/61386231/111884743-34606b80-89cc-11eb-9e4d-b6693a56c5a7.png)

# Індексація

Додамо пост в ES:

```javascript
// Додамо документ c id 1 типу post в індекс blog.

// Pretty вказує, що висновок повинен бути придатним для читання людиною.


PUT /blog/post/1?pretty

{
  "title": "Доповідь з ІПЗ",
  
  "content": "<p>Історія про довгу підготовку доповіді<p>",
  
  "tags": [
  
    "доповідь",
    
    "ІПЗ"
  ],
  
  "published_at": "2021-03-15T20:44:42+00:00"
  
}
```

Отримаємо таку відповідь серверу:

![image](https://user-images.githubusercontent.com/61386231/112749346-70965c00-8fca-11eb-965b-7e615f4df9c1.png)

ES автоматично створив індекс blog і тип post. Можна провести умовну аналогію: індекс - це база даних, а тип - таблиця в цій БД. Кожен тип має свою схему - mapping, також як і реляційна таблиця. Mapping генерується автоматично при індексації документа:

```javascript
// Отримаємо mapping всіх типів індексу blog

GET /blog/_mapping?pretty
```
відповідь серверу:

![image](https://user-images.githubusercontent.com/61386231/112749395-cbc84e80-8fca-11eb-941c-2aa2d0dea70f.png)

Варто відзначити, що ES не робить різниці між поодиноким значенням і масивом значень. Наприклад, поле title містить просто заголовок, а поле tags - масив рядків, хоча вони представлені в mapping однаково.

# Запити

## Витяг документа по його id:

```javascript
#/ Винесемо документ з id 1 типу post з індексу blog

GET /blog/post/1?pretty
```

![image](https://user-images.githubusercontent.com/61386231/112760110-8c1b5a00-8ffe-11eb-8756-e4c103657d62.png)

У відповіді з'явилися нові ключі: _version і _source. Взагалі, всі ключі, що починаються з _ відносяться до службових.


Ключ _version показує версію документа. Він потрібен для роботи механізму оптимістичних блокувань. Наприклад, ми хочемо змінити документ, що має версію 1. Ми відправляємо змінений документ і вказуємо, що це правка документа з версією 1. Якщо хтось інший теж редагував документ з версією 1 і відправив зміни раніше нас, то ES не прийме наші зміни, тому він зберігає документ з версією 2.


Ключ _source містить той документ, який ми індексували. ES не використовує це значення для пошукових операцій, тому що для пошуку використовуються індекси. Для економії місця ES зберігає стислий вихідний документ. Якщо нам потрібен тільки id, а не весь вихідний документ, то можна відключити зберігання исходника.


Якщо нам не потрібна додаткова інформація, можна отримати тільки вміст _source:

```javascript
GET /blog/post/1/_source?pretty
```

![image](https://user-images.githubusercontent.com/61386231/112760161-be2cbc00-8ffe-11eb-834a-8f4ecc0eb878.png)

Також можна вибрати тільки певні поля:

```javascript
// Винесемо тільки поле title

GET /blog/post/1?_source=title&pretty
```

![image](https://user-images.githubusercontent.com/61386231/112761471-27fb9480-9004-11eb-8a49-c1cf3803f1d2.png)

Проіндексуємо ще кілька постів і виконаємо більш складні запити.

```javascript
PUT /blog/post/2

{

  "title": "Підготовка прикладів",

  "content": "<p>Пошук найбільш показових та зрозумілих прикладів до доповіді<p>",

  "tags": [

    "приклади",

    "доповідь"

  ],

  "published_at": "2021-02-15T20:44:42+00:00"

}


PUT /blog/post/3

{

  "title": "Як я нарешті знайшов приклади до доповіді",

  "content": "<p>Довга історія з хорошим кінцем<p>",

  "tags": [

    "приклади"

  ],

  "published_at": "2014-07-21T20:44:42+00:00"

}
```

# Сортування

```javascript
// Знайдемо останній пост за датою публікації і винесемо поля title та published_at

GET /blog/post/_search?pretty

{

  "size": 1,

  "_source": ["title", "published_at"],

  "sort": [{"published_at": "desc"}]

}
```

Отримаємо:

![image](https://user-images.githubusercontent.com/61386231/112761849-d5bb7300-9005-11eb-884f-8917e2ae472a.png)

Ми вибрали останній пост. size обмежує кількість документів у видачі. total показує загальне число документів, що підходять під запит. sort у видачі містить масив цілих чисел, за якими проводиться сортування. Тобто дата перетворилася в ціле число.

# Повнотекстовий пошук

Три наших документа містять в полі content наступне:

+ <p>Історія про довгу підготовку доповіді<p>
+ <p>Пошук найбільш показових та зрозумілих прикладів до доповіді<p>
+ <p>Довга історія з хорошим кінцем<p>

Використовуємо match query для пошуку id документів, що містять задане слово:

```javascript
// source: false означає, що не потрібно витягувати _source знайдених документів

GET /blog/post/_search?pretty

{

  "_source": false,

  "query": {

    "match": {

      "content": "історія"

    }

  }

}
```

![image](https://user-images.githubusercontent.com/61386231/112762552-de617880-9008-11eb-9b70-e62063e4a989.png)

Однак, якщо шукати "історії" в поле контент, то ми нічого не знайдемо, тому що в індексі містяться тільки оригінальні слова, а не їх основи. Для того щоб зробити якісний пошук, потрібно налаштувати аналізатор.

Поле _score показує релевантність. Якщо запит виконується в filter context, то значення _score завжди дорівнюватиме 1, що означає повну відповідність фільтру.

# Аналізатори

Аналізатори потрібні, щоб перетворити вихідний текст в набір токенів.
Аналізатори складаються з одного Tokenizer і декількох необов'язкових TokenFilters. Tokenizer може передувати декільком CharFilters. Tokenizer розбивають вихідну рядок на токени, наприклад, по прогалин і символів пунктуації. TokenFilter може змінювати токени, видаляти або додавати нові, наприклад, залишати тільки основу слова, прибирати приводи, додавати синоніми. CharFilter - змінює вихідну рядок цілком, наприклад, вирізає html теги.

У ES є кілька стандартних аналізаторів. Наприклад, аналізатор english.

Скористаємося api і подивимося, як аналізатори standard і russian перетворять рядок "Story about preparing for a couple":



